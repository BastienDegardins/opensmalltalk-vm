Class {
	#name : #VMBlockTest,
	#superclass : #VMInterpreterTests,
	#pools : [
		'VMObjectIndices',
		'VMSqueakClassIndices'
	],
	#category : #'VMMakerTests-InterpreterTests'
}

{ #category : #supports }
VMBlockTest >> anEmptyMethod [
]

{ #category : #'as yet unclassified' }
VMBlockTest >> evaluateBlockReadingOuterMethodVariable [

	| aVariable |
	aVariable := 42.
	^ [ aVariable ] value 
]

{ #category : #'as yet unclassified' }
VMBlockTest >> evaluateBlockWritingAndReadingOuterMethodVariable [

	| aVariable |
	^ [ 
	  aVariable := 42.
	  aVariable ] value
]

{ #category : #'as yet unclassified' }
VMBlockTest >> evaluateBlockWritingOuterMethodVariable [

	| aVariable |
	[ aVariable := 42 ] value.
	^ aVariable
]

{ #category : #'as yet unclassified' }
VMBlockTest >> evaluatingABlock [

  ^[42] value
]

{ #category : #'as yet unclassified' }
VMBlockTest >> evaluatingABlockWithLocalBlockVariable [

	^ [ 
	  | aVariable |
	  aVariable := 42.
	  aVariable ] value
]

{ #category : #'as yet unclassified' }
VMBlockTest >> evaluatingABlockWithNonLocalReturn [

  [^1] value
]

{ #category : #testing }
VMBlockTest >> executeMethod: aMethodToTest [

	| methodReturning initialMethod |
	
	methodReturning := self createMethodOopFromPharoMethod: aMethodToTest.
	initialMethod := self createMethodOopFromPharoMethod:
		                     self class >> #anEmptyMethod.

	"We want to avoid baseFrameReturn (base frame initialisation)"
	stackBuilder addNewFrame method: initialMethod.
	stackBuilder addNewFrame
		method: methodReturning;
		temps: ((1 to: aMethodToTest numTemps) collect: [ :i | memory nilObject ]);
		receiver: memory trueObject.
	stackBuilder buildStack.
	
	interpreter instructionPointer: (methodBuilder bytecodeAt: 0 forMethod: methodReturning).
	interpreter interpretWhile: [ interpreter method = methodReturning ].

]

{ #category : #supports }
VMBlockTest >> executeMethod: aMethodToTest stopAfterBytecode: aBytecode [

	| methodReturning initialMethod flag|
	methodReturning := self createMethodOopFromPharoMethod: aMethodToTest.
	initialMethod := self createMethodOopFromPharoMethod:
		                 self class >> #anEmptyMethod.

	"We want to avoid baseFrameReturn (base frame initialisation)"
	stackBuilder addNewFrame method: initialMethod.
	stackBuilder addNewFrame
		method: methodReturning;
		temps:
			((1 to: aMethodToTest numTemps) collect: [ :i | memory nilObject ]);
		receiver: memory trueObject.
	stackBuilder buildStack.

	interpreter instructionPointer:
		(methodBuilder bytecodeAt: 0 forMethod: methodReturning).
	interpreter interpretWhile: [ 
		interpreter currentBytecode = aBytecode
			ifTrue: [ 
				flag := true. "we reached our bytecode"
				true "we execute the bytecode"]
			ifFalse: [ flag ifNil: [ flag := false ]. flag not] ].
		
	"for convenience this return the method which is need for testEvaluatingABlockCreatesAFrame"
	 ^methodReturning
]

{ #category : #supports }
VMBlockTest >> executeMethod: aMethodToTest stopBeforeBytecode: aBytecode [

	| methodReturning initialMethod |
	methodReturning := self createMethodOopFromPharoMethod: aMethodToTest.
	initialMethod := self createMethodOopFromPharoMethod:
		                 self class >> #anEmptyMethod.

	"We want to avoid baseFrameReturn (base frame initialisation)"
	stackBuilder addNewFrame method: initialMethod.
	stackBuilder addNewFrame
		method: methodReturning;
		temps:
			((1 to: aMethodToTest numTemps) collect: [ :i | memory nilObject ]);
		receiver: memory trueObject.
	stackBuilder buildStack.

	interpreter instructionPointer:
		(methodBuilder bytecodeAt: 0 forMethod: methodReturning).
	interpreter interpretWhile: [ (interpreter currentBytecode = aBytecode) not ]
]

{ #category : #supports }
VMBlockTest >> methodReturningABlock [
	
	^ []
	
]

{ #category : #'as yet unclassified' }
VMBlockTest >> methodReturningABlockInsideABlockWithLocal [
	
	true ifTrue:[|anArgument| anArgument := 2.
		^[anArgument]]
	
]

{ #category : #supports }
VMBlockTest >> methodReturningABlockWithTwoArguments [
	
	^ [:a :b]
	
]

{ #category : #supports }
VMBlockTest >> methodWithLocalReturningABlock [

	| a |
	a:= 1.
	^ [ a ]
]

{ #category : #running }
VMBlockTest >> setUp [

   super setUp.
	self installArrayClass.
	self installBlockClosureClass.
]

{ #category : #testing }
VMBlockTest >> testCreatingABlockClosureShouldCopyUsedMethodVariable [

	| methodToTest |
	methodToTest := self class >> #methodWithLocalReturningABlock.

	self executeMethod: methodToTest.
	"We assign 1 to the local variable of the method, see methodWithLocalReturningABlock"
	self
		assert: (memory
				 fetchPointer: ClosureFirstCopiedValueIndex
				 ofObject: interpreter stackTop)
		equals: (memory integerObjectOf: 1)
]

{ #category : #testing }
VMBlockTest >> testCreatingABlockClosureShouldHaveCorrectPC [

	| methodToTest |
	methodToTest := self class >> #methodReturningABlock.

	self executeMethod: methodToTest.

	self flag:#'hard code for now should be modified'.
	self
		assert: (memory
				 fetchPointer: ClosureStartPCIndex
				 ofObject: interpreter stackTop)
		equals: (memory integerObjectOf: 29)
]

{ #category : #testing }
VMBlockTest >> testCreatingABlockClosureShouldHaveOuterContextObject [

	| methodToTest |
	methodToTest := self class >> #methodReturningABlock.

	self executeMethod: methodToTest.

	"Currently fails because the stack frame is not overriden.
	So the interpreter considers it's still married even thought the stack frame is already dead"

	self assert: (interpreter isWidowedContext:
			 (memory outerContextOf: interpreter stackTop))
]

{ #category : #'as yet unclassified' }
VMBlockTest >> testCreatingABlockInsideABlockClosureShouldCopyUsedBlockVariable [

	| methodToTest |
	methodToTest := self class
	                >> #methodReturningABlockInsideABlockWithLocal.

	self executeMethod: methodToTest.

	"We assign 2 to the local variable of the block, see methodReturningABlockInsideABlock"
	self
		assert: (memory
				 fetchPointer: ClosureFirstCopiedValueIndex
				 ofObject: interpreter stackTop)
		equals: (memory integerObjectOf: 2)
]

{ #category : #testing }
VMBlockTest >> testCreatingABlockWithTwoArgumentsClosureShouldHaveTwoArguments [

	| methodToTest |
	methodToTest := self class >> #methodReturningABlockWithTwoArguments.

	self executeMethod: methodToTest.

	self
		assert: (memory
				 fetchPointer: ClosureNumArgsIndex
				 ofObject: interpreter stackTop)
		equals: (memory integerObjectOf: 2)
]

{ #category : #testing }
VMBlockTest >> testCreatingABlockWithoutArgumentsClosureShouldHaveNoArgument [

	| methodToTest |
	methodToTest := self class >> #methodReturningABlock.

	self executeMethod: methodToTest.
	self
		assert: (memory
				 fetchPointer: ClosureNumArgsIndex
				 ofObject: interpreter stackTop)
		equals: (memory integerObjectOf: 0)
]

{ #category : #'as yet unclassified' }
VMBlockTest >> testEvaluatingABlock [

	| methodToTest |
	methodToTest := self class >> #evaluatingABlock.

	self executeMethod: methodToTest.

	self
		assert: interpreter stackTop
		equals: (memory integerObjectOf: 42)
]

{ #category : #'as yet unclassified' }
VMBlockTest >> testEvaluatingABlockWithLocalBlockVariable [

	| methodToTest |
	methodToTest := self class >> #evaluatingABlockWithLocalBlockVariable.

	self executeMethod: methodToTest.

	self
		assert: interpreter stackTop
		equals: (memory integerObjectOf: 42)
]

{ #category : #'as yet unclassified' }
VMBlockTest >> testEvaluatingABlockWithLocalMethodVariableRead [

	| methodToTest |
	methodToTest := self class >> #evaluateBlockReadingOuterMethodVariable.

	self executeMethod: methodToTest.

	self
		assert: interpreter stackTop
		equals: (memory integerObjectOf: 42)
]

{ #category : #'as yet unclassified' }
VMBlockTest >> testEvaluatingABlockWithLocalMethodVariableReadAndWrite [

	| methodToTest |
	methodToTest := self class >> #evaluateBlockWritingAndReadingOuterMethodVariable.

	self executeMethod: methodToTest.

	self
		assert: interpreter stackTop
		equals: (memory integerObjectOf: 42)
]

{ #category : #'as yet unclassified' }
VMBlockTest >> testEvaluatingABlockWithLocalMethodVariableWrite [

	| methodToTest |
	methodToTest := self class >> #evaluateBlockWritingOuterMethodVariable.

	self executeMethod: methodToTest.

	self
		assert: interpreter stackTop
		equals: (memory integerObjectOf: 42)
]

{ #category : #'as yet unclassified' }
VMBlockTest >> testEvaluatingABlockWithNonLocalReturn [

	| methodToTest |
	methodToTest := self class >> #evaluatingABlockWithNonLocalReturn.

	self executeMethod: methodToTest.

	self assert: true
]

{ #category : #testing }
VMBlockTest >> testPushClosureBytecodePushesClosure [

	|methodToTest|
	methodToTest := self class >> #methodReturningABlock.
	
	self executeMethod: methodToTest.

	self
		assert: (memory fetchClassOf: interpreter stackTop)
		equals: (memory classAtIndex: ClassBlockClosureCompactIndex)
]
